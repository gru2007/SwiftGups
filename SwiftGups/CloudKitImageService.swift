import Foundation
import CloudKit
import SwiftData
import UIKit
import os.log

/// –°–µ—Ä–≤–∏—Å –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ CloudKit Assets
@MainActor
class CloudKitImageService: ObservableObject {
    @Published var isUploading = false
    @Published var isDownloading = false
    @Published var syncProgress: Double = 0.0
    @Published var lastSyncError: Error?
    
    private let container = CKContainer.default()
    private var privateDatabase: CKDatabase {
        container.privateCloudDatabase
    }
    
    /// –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ CloudKit –∫–∞–∫ Asset
    func uploadImage(
        _ image: UIImage, 
        for homework: Homework,
        originalFilename: String = "",
        context: ModelContext
    ) async throws -> HomeworkAttachment {
        
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            throw CloudKitImageError.invalidImageData
        }
        
        isUploading = true
        syncProgress = 0.0
        
        defer {
            Task { @MainActor in
                isUploading = false
                syncProgress = 0.0
            }
        }
        
        do {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å CloudKit
            let accountStatus = try await container.accountStatus()
            guard accountStatus == .available else {
                throw CloudKitImageError.iCloudUnavailable
            }
            
            // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è CKAsset
            let tempURL = createTemporaryFile(data: imageData, filename: originalFilename)
            let asset = CKAsset(fileURL: tempURL)
            
            // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å CloudKit –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            let record = CKRecord(recordType: "HomeworkImage")
            record["homeworkId"] = homework.id.uuidString as NSString
            record["image"] = asset
            record["originalFilename"] = originalFilename as NSString
            record["fileSize"] = imageData.count as NSNumber
            record["mimeType"] = "image/jpeg" as NSString
            record["uploadedAt"] = Date() as NSDate
            
            syncProgress = 0.5
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ CloudKit
            let savedRecord = try await privateDatabase.save(record)
            
            syncProgress = 0.8
            
            // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ –≤ SwiftData
            let attachment = HomeworkAttachment(
                id: savedRecord.recordID.recordName,
                homeworkId: homework.id.uuidString,
                type: .image,
                filename: "\(UUID().uuidString).jpg",
                originalFilename: originalFilename,
                fileSize: imageData.count,
                mimeType: "image/jpeg"
            )
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
            let localPath = await AttachmentManager.shared.saveImage(image, withFilename: attachment.filename)
            if let localPath = localPath {
                attachment.markAsDownloaded(localPath: localPath)
            }
            
            // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–µ –≤ CloudKit
            if let assetURL = savedRecord["image"] as? CKAsset {
                attachment.markAsUploaded(cloudAssetURL: assetURL.fileURL?.absoluteString ?? "")
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫ –¥–æ–º–∞—à–Ω–µ–º—É –∑–∞–¥–∞–Ω–∏—é
            context.insert(attachment)
            homework.addCloudAttachment(attachment)
            
            syncProgress = 1.0
            
            // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            try? FileManager.default.removeItem(at: tempURL)
            
            os_log("‚úÖ Image uploaded to CloudKit successfully", log: .default, type: .info)
            
            return attachment
            
        } catch {
            lastSyncError = error
            os_log("‚ùå Failed to upload image to CloudKit: %@", log: .default, type: .error, error.localizedDescription)
            throw error
        }
    }
    
    /// –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ CloudKit
    func downloadImage(attachment: HomeworkAttachment) async throws -> UIImage? {
        guard let cloudAssetURL = attachment.cloudAssetURL,
              !cloudAssetURL.isEmpty else {
            throw CloudKitImageError.noCloudAsset
        }
        
        isDownloading = true
        syncProgress = 0.0
        
        defer {
            Task { @MainActor in
                isDownloading = false
                syncProgress = 0.0
            }
        }
        
        do {
            // –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å—å –∏–∑ CloudKit
            let recordID = CKRecord.ID(recordName: attachment.id)
            let record = try await privateDatabase.record(for: recordID)
            
            syncProgress = 0.3
            
            guard let asset = record["image"] as? CKAsset,
                  let assetURL = asset.fileURL else {
                throw CloudKitImageError.invalidAsset
            }
            
            syncProgress = 0.6
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            let imageData = try Data(contentsOf: assetURL)
            guard let image = UIImage(data: imageData) else {
                throw CloudKitImageError.invalidImageData
            }
            
            syncProgress = 0.9
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
            let localPath = await AttachmentManager.shared.saveImage(image, withFilename: attachment.filename)
            if let localPath = localPath {
                attachment.markAsDownloaded(localPath: localPath)
            }
            
            syncProgress = 1.0
            
            os_log("‚úÖ Image downloaded from CloudKit successfully", log: .default, type: .info)
            
            return image
            
        } catch {
            lastSyncError = error
            attachment.syncStatus = .error
            os_log("‚ùå Failed to download image from CloudKit: %@", log: .default, type: .error, error.localizedDescription)
            throw error
        }
    }
    
    /// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è
    func syncHomeworkImages(_ homework: Homework, context: ModelContext) async {
        os_log("üîÑ Starting sync for homework images", log: .default, type: .info)
        
        var uploadCount = 0
        var downloadCount = 0
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ CloudKit
        for localAttachment in homework.imageAttachments {
            if let image = AttachmentManager.shared.loadImage(localAttachment) {
                do {
                    let _ = try await uploadImage(image, for: homework, originalFilename: localAttachment, context: context)
                    uploadCount += 1
                    
                    // –£–¥–∞–ª—è–µ–º –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –≤ CloudKit
                    homework.removeAttachment(localAttachment)
                    AttachmentManager.shared.deleteAttachment(localAttachment)
                    
                } catch {
                    os_log("‚ö†Ô∏è Failed to upload local image %@: %@", log: .default, type: .info, localAttachment, error.localizedDescription)
                }
            }
        }
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º CloudKit –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ
        if let cloudAttachments = homework.cloudAttachments {
            for cloudAttachment in cloudAttachments {
                if cloudAttachment.type == .image && !cloudAttachment.isDownloaded {
                    do {
                        let _ = try await downloadImage(attachment: cloudAttachment)
                        downloadCount += 1
                    } catch {
                        os_log("‚ö†Ô∏è Failed to download cloud image %@: %@", log: .default, type: .info, cloudAttachment.id, error.localizedDescription)
                    }
                }
            }
        }
        
        homework.lastImageSync = Date()
        
        os_log("‚úÖ Homework image sync completed: %d uploaded, %d downloaded", log: .default, type: .info, uploadCount, downloadCount)
    }
    
    /// –£–¥–∞–ª—è–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ CloudKit
    func deleteCloudImage(_ attachment: HomeworkAttachment) async throws {
        guard attachment.isUploaded else { return }
        
        do {
            let recordID = CKRecord.ID(recordName: attachment.id)
            try await privateDatabase.deleteRecord(withID: recordID)
            
            // –£–¥–∞–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
            if let localPath = attachment.localCachedPath {
                AttachmentManager.shared.deleteAttachment(localPath)
            }
            
            os_log("‚úÖ Image deleted from CloudKit successfully", log: .default, type: .info)
            
        } catch {
            os_log("‚ùå Failed to delete image from CloudKit: %@", log: .default, type: .error, error.localizedDescription)
            throw error
        }
    }
    
    // MARK: - Private Helpers
    
    private func createTemporaryFile(data: Data, filename: String) -> URL {
        let tempDirectory = FileManager.default.temporaryDirectory
        let tempFilename = filename.isEmpty ? "\(UUID().uuidString).jpg" : filename
        let tempURL = tempDirectory.appendingPathComponent(tempFilename)
        
        do {
            try data.write(to: tempURL)
        } catch {
            os_log("‚ùå Failed to create temporary file: %@", log: .default, type: .error, error.localizedDescription)
        }
        
        return tempURL
    }
    
    /// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å CloudKit –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    func checkCloudKitAvailability() async -> Bool {
        do {
            let accountStatus = try await container.accountStatus()
            return accountStatus == .available
        } catch {
            return false
        }
    }
    
    /// –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
    func getSyncStats(for homework: Homework) -> HomeworkSyncStats {
        let totalImages = homework.allImageAttachments.count
        let syncedImages = homework.cloudAttachments?.filter { $0.type == .image && $0.isUploaded }.count ?? 0
        let pendingImages = homework.imageAttachments.count // –õ–æ–∫–∞–ª—å–Ω—ã–µ, –Ω–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
        let errorImages = homework.cloudAttachments?.filter { $0.syncStatus == .error }.count ?? 0
        
        return HomeworkSyncStats(
            totalImages: totalImages,
            syncedImages: syncedImages,
            pendingImages: pendingImages,
            errorImages: errorImages,
            lastSync: homework.lastImageSync
        )
    }
}

// MARK: - Error Types

enum CloudKitImageError: Error, LocalizedError {
    case invalidImageData
    case iCloudUnavailable
    case noCloudAsset
    case invalidAsset
    case syncFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .invalidImageData:
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
        case .iCloudUnavailable:
            return "iCloud –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
        case .noCloudAsset:
            return "–û–±–ª–∞—á–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
        case .invalidAsset:
            return "–ü–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ iCloud"
        case .syncFailed(let message):
            return "–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: \(message)"
        }
    }
}

// MARK: - Stats Types

struct HomeworkSyncStats {
    let totalImages: Int
    let syncedImages: Int
    let pendingImages: Int
    let errorImages: Int
    let lastSync: Date
    
    var isFullySynced: Bool {
        return pendingImages == 0 && errorImages == 0 && totalImages > 0
    }
    
    var syncPercentage: Double {
        guard totalImages > 0 else { return 1.0 }
        return Double(syncedImages) / Double(totalImages)
    }
}
